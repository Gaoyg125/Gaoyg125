# 栈和队列
- *栈和队列的数据关系也是“一对一”，所以也是线性表，因此栈和队列分别存在顺序表和链表两种形式。*
## 1 栈的基本概述
### 1.1 栈的定义
- 栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。
### 1.2 栈的特点
- 栈只能从表的一端存取数据，另一端是封闭的。
- 在栈中，无论是存数据还是取数据，都必须遵循"**先进后出**"的原则，即最先进栈的元素最后出栈。
- 栈的开口端被称为**栈顶**；封口端被称为**栈底**。
- **栈顶元素**指的就是距离栈顶最近的元素，**栈底元素**指的是位于栈最底部的元素。
### 1.3 栈的基本操作
- 1.向栈中添加元素，此过程被称为"**进栈**"（**入栈或压栈**）。
- 2.从栈中提取出指定元素，此过程被称为"**出栈**"（或**弹栈**）；
### 1.4 栈的实现
- 1.顺序栈
  * 采用**顺序存储结构**可以模拟栈存储数据的特点，从而实现栈存储结构。
- 2.链栈
  * 采用**链式存储结构**实现栈结构。
- 两者实现区别：仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。
### 1.5 栈的实例
- 网页的回退功能。

## 2 顺序栈
### 2.1 定义
- 顺序栈：用顺序表实现栈存储结构。
### 2.2 基本操作
- 基本操作主要是入栈和出栈。
- 实现思想：顺序表采用数组实现，当数组为空时，也就是空栈。数组底端为栈底，另一端为栈顶。建立一个变量top指向栈顶（即对应数组的最后一个元素的索引），初始化为-1，表示空栈。（1）当入栈时，只要对应数组的位置赋值，同时该变量加1；（2）出栈时，top减1即可，出栈的元素不用删除，因为已经不属于数组中了，相当于是脏值了。
```c
#include<stdio.h>
#define MAXSIZE 10
#define ERROR -1
//1.入栈操作
int push(int *arr, int top, int data)
{
	if (!arr)
	{
		return ERROR;
	}
	top++;
	arr[top] = data;
}
//2.出栈操作
int pop(int *arr, int top)
{
  if (!arr)
	{
		return top;
	}
	if (top == -1)
	{
		printf("此时的arr为空栈\n");
		return ERROR;
	}
	printf("出栈元素是：%d\t", arr[top]);
	top--;
	return top;
}
void main()
{
	int arr[MAXSIZE];
	int top = -1;//表示空栈
	for(int i = 0; i < MAXSIZE; i++)
	{
		top = push(arr, top, i);
	}
	for (int i = 0; i < MAXSIZE; i++)
	{
		top = pop(arr, top);
	}
}
```
- 通过上面的入栈和出栈操作，发现可以应用到逆序打印数组。
## 3 链栈
### 3.1定义
- 链栈：用链表实现栈存储结构。
- 将链表的头部作为栈顶，尾部作为栈底，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。
### 3.2基本操作
- 链表的头部作为栈顶：
* 在实现数据"入栈"操作时，需要将数据从链表的头部插入；
* 在实现数据"出栈"操作时，需要删除链表头部的首元节点。
- 链栈实际上就是一个只能采用头插法插入或删除数据的链表。
### 3.3 代码实现
```c
#include<stdio.h>
#include<malloc.h>
//1.创建链表结点
typedef struct Node
{
	int data;
	struct Node* next;
}node;

//2.头插法入栈
node* push(node *pHead, int Elem)
{
	node *pTemp = (node*)malloc(sizeof(node));
	pTemp->data = Elem;
	pTemp->next = pHead;//新结点与老头结点连接
	pHead = pTemp;//更新头指针的位置
	return pHead;
}
//3.出栈
node* pop(node *pHead)
{
	if(pHead)
	{
		node *pTemp = (node*)malloc(sizeof(node));
		pTemp = pHead;
		pHead = pHead->next;
		printf("出栈元素：%d\t", pTemp->data);
		if (pHead)
		{
			printf("新栈顶元素：%d\n", pHead->data);
		}
		else
		{
			printf("栈已空");
		}
		free(pTemp);
		pTemp = NULL;
	}
	else
	{
		printf("空栈");
		return 0;
	}
	return pHead;
}
void main()
{
	node *pHead = NULL;
	for (int i = 1; i < 5; i++)
	{
		pHead = push(pHead, i);
	}
	for (int i = 1; i < 5; i++)
	{
		pHead = pop(pHead);
	}
}
```

## 4 队列
### 4.1 队列的定义
- 队列：要求数据只能从一端进，从另一端出的线性表。
### 4.2 队列的特点
- 遵循“先进先出”原则。
- 进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。

### 4.3 队列的两种存储结构
  * 顺序队列：用顺序表实现的队列结构；
  * 链队列：用链表实现的队列结构；
#### 4.3.1 顺序队列
- **方法1**
  * 步骤1.创建一个空间足够的数组，创建两个变量top和rear,top指向队头(即数组索引0处)，rear指向队尾(即数组有元素的末尾)。
  * 步骤2.未初始化时，数组为空，所以top = rear = 数组索引0。
  * 步骤3.进队列，rear+1。
  * 步骤4.出队列，top+1。实际出队列，并不是在数组中删除出队列的元素，这个要注意。
```c
#include<stdio.h>
#define SIZE 10
int AddQueue(int *arr, int rear, int data)
{
	arr[rear] = data;
	rear++;
	return rear;
}
void DelQueue(int* arr, int top, int rear)
{
	if (top == rear)
	{
		printf("是一个空队列");
	}
	while (top != rear)
	{
		printf("出队列的元素是:%d\t", arr[top]);
		top++;
	}
	printf("%d,%d",top,rear); //top == rear == 9
}
void main()
{
	//1.创建一块大内存数组作为队列使用的空间
	int arr[SIZE];
	//2.创建2个变量，使其初始位置为arr[0]
	int top, rear;
	top = rear = 0;
	//3.调用入队
	for (int i = 0; i < SIZE - 1; i++)
	{
		rear = AddQueue(&arr[0],rear,i);
	}
	//4.调用出队
	DelQueue(&arr[0], top, rear);
	printf("\n");
}
```
  - 方法1的缺点：当队列元素全部被请出后，top和rear均指向数组真实有值的最后一个索引处，不是索引0处，导致前面的一段内存不能使用，如果当该数组的内存全使用完，容易造成溢出。
  - **方法2**
  - * 方法1存在顺序队列出现满了之后，就会溢出，我们可以构建一个循环的顺序队列，通过对数组的最大值求余即可实现循环。
```c
#include<stdio.h>
#define SIZE 5
int AddQuene(int *arr, int rear, int data)
{
	arr[rear % SIZE] = data;
	printf("入队元素是：arr[%d] = %d\n", rear, arr[rear]);
	rear = (rear + 1) % SIZE; //目的是为了当超过最大长度可以循环使用前面的空间。
	return rear; 
}
int DelQuene(int *arr, int top, int rear)
{
	if (top == rear)
	{
		printf("空队列");
	}
	printf("出队元素：arr[%d] = %d\n",top, arr[top]);
	top = (top + 1) % SIZE; //目的是为了当超过最大长度可以循环使用前面的空间。
	return top;
}
void main()
{
	//1.创建一个数组
	int arr[SIZE];
	//2.创建两个变量来指明队头(top)和队尾(rear)
	int top, rear;
	top = rear = 0; //此时队列为空
	for (int i = 0; i < 10; i++)
	{
		printf("第%d次入队", i + 1);
		//3.调用入队函数
		rear = AddQuene(arr, rear, 1);
		//4.调用出队函数
		top = DelQuene(arr, top, rear);
		printf("队头索引：%d,队尾索引：%d\n", top, rear);
	}
}
```
#### 4.3.2 链式队列
- 使用链表实现的队列存储结构叫链式队列。
- 实现思想：
  * 步骤1.创建两个指针top(队头)和rear(队尾)，同时指向头结点，此时队列中为空。
  * 步骤2.入队操作：创建一个新结点，表示新增结点；新结点与原尾结点rear连接；原先的rear移至新节点处，即新结点变成尾结点。
  * 步骤3.出队操作：通过头结点找到队头，创建一个指针temp，指向即将出队的结点（出队的队头），将该结点从链表中摘除，并释放该结点的内存。
```c
#include<stdio.h>
#include<malloc.h>
typedef struct Node
{
    int data;
	int *next;
}node;

//入队函数
node* AddQuene(node *rear, int data)
{
	if (rear)
	{
		//创建新结点
		node *temp = (node*)malloc(sizeof(node));
		if (temp)
		{
			temp->data = data;
			temp->next = NULL;
			//将新结点和尾结点相连
			rear->next = temp;
			rear = temp;
		}
		return rear;
	}
	return rear;
}

//出队函数
node* DelQuene(node *top)
{
	if (top->next == NULL)
	{
		printf("空队列");
		return top;
	}
	//创建一个指针指向队头。
	node *p = top->next;
	printf("出队列元素为%d\n", p->data);
	top = p;
	free(p);
	return top;
}

void main()
{
	//1.创建一个头结点
	node *pHead = (node*)malloc(sizeof(node));
	pHead->next = NULL;
	//2.创建两个指针指向头结点，此时队列为空
	node *top, *rear;
	top = rear = pHead;
	for (int i = 0; i < 10; i++)
	{
		//调用入队
		rear = AddQuene(rear, i*3+1);
		//调用出队
		top = DelQuene(top);
	}
}
```

