# 静态链表与双向链表
@[TOC]
## 1 静态链表
- 创建
  
  * 静态链表的**结点**组成是由**数据域**和**整形游标**组成。
  * 备用链表：是指将静态链表中未存放的数据连接起来的链表，其头指针指向a[0]。
  * 数据链表：是指静态链表中存放数据的结点连接起来的链表，其头指针指向a[1]。
  * 静态链表的特点：a[0]的结点位置上是不存放数据的。
- 创建步骤
   * 步骤1.在静态链表未初始化前，数组中的位置都是空闲态，因此全连接在备用链表上。
   * 步骤2.逐渐添加数据，将备用链表中的a[0]后继结点摘除，作为数据链表的当前最后一个结点。即备用链表的a[0]的后继结点向后移动一个。
- 代码实现
```c
#include<stdio.h>
#define MAXSIZE 6
//定义一个结点
typedef struct Link {
    int data;
    int cur;
}link;

//1.创建备用链表
void RsvLink(link* arr)
{
    for (int i = 0; i < MAXSIZE; i++)
    {
        arr[i].data = 0xFF; //初始化为脏值
        arr[i].cur = i + 1;
    }
    arr[MAXSIZE - 1].cur = 0; //链表最后一个指向游标0
}
//2.从备用链表中摘除被分配的结点
int MallocArr(link* arr)
{
    int i = arr[0].cur; //记录备用链表中第二结点对应的游标，当分配到链表最后一个结点时，该值为0.
    if (arr[0].cur) //如果不是最后一个结点
    {
        arr[0].cur = arr[i].cur; //备用链表删除一个结点后，首结点中存的游标向下一个结点移动。
    }
    return i;
}
//3.初始化静态链表
int InitArr(link* arr)
{
    RsvLink(arr);
    int Head = MallocArr(arr); //空静态链表的头结点中存在的游标
    int Tail = Head;//空链表，所以头尾一样
    for (int i = 1; i < 4; i++)
    {
        int j = MallocArr(arr); //从备用链表拿出结点的游标
        arr[Tail].cur = j;
        arr[j].data = i; //数据域初始化
        Tail = j; //指向链表后一个结点的游标后移
    }
    arr[Tail].cur = 0; //新的链表最后结点游标为0
    return Head;
}
//4.打印链表
void DisPlayArr(link* arr, int body)
{
    int Temp = body;
    while (arr[Temp].cur)
    {
        printf("%d,%d\t", arr[Temp].data, arr[Temp].cur);
        Temp = arr[Temp].cur;
    }
    printf("%d,%d\t", arr[Temp].data, arr[Temp].cur); //打印最后一个结点，游标是0的结点
}
//创建静态链表
void main()
{
    link arr[MAXSIZE];
    int Head = InitArr(arr);
    printf("静态链表是：\n");
    DisPlayArr(arr, Head);
}
```

- 基本操作
  * 添加
  * 删除
  * 查找
  * 更改
## 静态链表和动态链表的区别
  |     |静态链表 | 动态链表 |
  | --- | --- | --- |
  |  内存 | 预先申请足够空间 | 需要新增结点时开空间 |
  | 链表数量 | 2条(备用链表，数据链表) | 1条 |

## 2 双向链表
### 1.背景
* 单链表的指针域只有一个指向后继元素，因此适合从前往后找数据。因此想从后往前找数据就需要双链表。
### 2.定义
  * 双向链表是存在两个指针域的链表，各个结点之间的关系是双向的，但头指针一般设置1个，除非实际情况需要。
### 3.组成
  * 指针域(prior)：指向当前结点的**前驱**结点；
  * 数据域(data)：当前结点的数据元素；
  * 指针域(next)：指向当前结点的**后驱**结点；
### 4.创建思想
  * 与单链表相似，只是多了如下步骤：
  * 将当前的新结点的prior指针指向前驱结点；
  * 同时将当前新结点的直接前驱结点next指针指向当前新结点。
### 5.代码实现
```c
#include<stdio.h>
#include<stdlib.h>

//1.创建结点
typedef struct Link
{
    struct Link *prior;
    int data;
    struct Link *next;
}link;

//2.创建双向链表
link* InitDoubLink(link *pHead, int len)
{
    pHead =(link*)malloc(sizeof(link));
    if(!pHead)
    {
        return 0;
    }
    //对首元结点初始化
    pHead->prior = NULL;
    pHead->next = NULL;
    pHead->data = 1;
    
    if (len < 1)
    {
        return pHead;
    }

    link *pTemp = pHead; //声明一个指针指向链表最后一个结点
    for (int i = 2; i <= len; i++)
    {
        //创建其他结点并赋值
        link *pBody = (link*)malloc(sizeof(link));
        if (!pBody)
        {
            return 0;
        }
        pBody->prior = NULL;
        pBody->next = NULL;
        pBody->data = i;
        pTemp->next = pBody; //前驱结点指向当前结点
        pBody->prior = pTemp; //当前结点指向前驱结点
        pTemp = pTemp->next; //最后一个结点向后移动
    }

    return pHead;
}
//3.打印双向链表
void Diaplay(link* pHead)
{
    link *pTemp = pHead;
    while (pTemp)
    {
        if (!pTemp->next)
        {
            printf("%d\n", pTemp->data);
        }
        else 
        {
            printf("%d <-> ", pTemp->data);
        }
        pTemp = pTemp->next;
    }
}
int main()
{
    int len = 5;//链表长度
    link* pLink = NULL;//创建一个头指针
    pLink = InitDoubLink(pLink,len); //调用链表创建函数
    Diaplay(pLink);//打印链表
    printf("链表中第4个结点直接的前驱是：%d", pLink->next->next->next->prior->data);
    return 0;
}
```

### 6.基本操作
  #### 1.添加结点
  * （1）添加至表头
  * 步骤1.将新头结点temp的next指向表头结点head，head的prior指针指向temp。
  * 步骤2.将head移至temp，重新指向新的表头。
  * （2） 添加在表中间
  * 步骤1.新结点与其前驱结点建立双层逻辑；
  * 步骤2.新结点与其后继结点建立双层逻辑。
  * （3）添加在表的末尾
  * 步骤1.找到双链表中最后一个结点；
  * 步骤2.让新结点与最后一个结点进行双向逻辑关系。
```c
 link* insertlink(link *head, int data, int add)
 {
    //新建temp结点
    link *temp = (link*)malloc(sizeof(link));
    temp->data = data;
    temp->prior = NULL;
    temp->next = NULL;

    //插入到链表头，要特殊考虑
    if(add == 1) 
    {
        temp->next = head; //新结点的后继指针指向原先的头指针
        head->prior = temp; //原先头指针的前驱指针指向新结点
        head = temp; //将原头结点移至新的temp结点（首结点）
    }
    else
    {
        link *body = head; //创建一个临时指针指向头结点
        for (int i = 1; i < add - 1; i++) //找到要插入位置的前一个结点
        {
            body = body->next;
        }
        //判断条件为真，说明插入位置为链表尾
        if (body->next == NULL) 
        {
            body->next = temp;
            temp->prior = body;
        }
        else //即插入的位置不是链表的尾部，而是中间位置
        {
            body->next->prior = temp; 
            temp->next = body->next;
            body->next = temp;
            temp->prior = body;
        }
    }
    return head;
 }
```
#### 2.删除结点
* 实现思想：遍历找到该结点然后将结点删除,并将该结点的内存释放。
~~~C
link *DelLink(link *pHead, int data)
{
    link *pTemp = pHead;
    //遍历链表，找到该值
    while(pTemp)
    {
        if(pTemp->data == data)
        {
            pTemp->prior->next = pTemp->next;
            pTemp->next->prior = pTemp->prior;
            free(pTemp);
            return pHead;
        }
        pTemp = pTemp->next;
    }
    printf("链表中没有该元素");
    return pHead;
}
```
  
#### 3.查找结点
* 实现思想:因为双链表和单链表一样，只有一个头指针，所以查找需要从头结点开始遍历查找。
*代码实现
```c
int FindElemLink(link *pHead,int data, int location)
{
    link *pTemp = pHead;
    location = 1; //第一个结点位置为索引1
    while(pTemp)
    {
        if(pTemp->data == data)
        {
            return location;
        }
        location++;
        pTemp = pTemp->next;
    }
    return -1;
}
```

#### 4.修改链表的结点元素
* 实现思想：先查找到该结点的位置，直接将数据域改写
* 代码实现
```c
link *PlaceElemLink(link *pHead, int Loc,int data)
{
    link *pTemp = pHead;
    for(int i = 1; i < Loc; i++) //提前知道位置，所以用for循环
    {
        //将pTemp指针移至到要被修改的数据的位置
        pTemp = pTemp->next;
    }
    temp->data = data;//修改结点上的数据
    return pHead;
}
```
